---
title: "Functional Annotation Analysis for *T. brucei* RNA-seq data"
author: "Kennedy Mwangi"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r echo=FALSE}
# required package
# library('AnnotationHub')
library('foreach')
library('doParallel')
library('goseq')
library('Trypanosoma.brucei.TREU927', character.only = TRUE)
library('org.Tb927.tritryp.db')
library('TxDb.TbruceiTREU927.tritryp43.genes')
library('dplyr')
library('rtracklayer')
library('tibble')

# load helper functions
source("~/manuscript-shared-rnaseq/R/enrichment_analysis.R")
source("~/manuscript-shared-rnaseq/R/annotations.R")
source("~/manuscript-shared-rnaseq/R/wgcna.R")
```

## Introduction
This document holds code to try out different criterias of functional annotation before incorporation in the main pipeline. It uses online tutorials listed below.

## Resources

- https://bioconductor.org/packages/devel/data/annotation/vignettes/EuPathDB/inst/doc/EuPathDB.html
- http://bioconductor.org/packages/release/bioc/vignettes/AnnotationHub/inst/doc/AnnotationHub-HOWTO.html
- https://bioconductor.org/packages/devel/bioc/vignettes/goseq/inst/doc/goseq.pdf

## Analysis

### Getting started

```{r eval=FALSE}
# create an AnnotationHub connection
ah <- AnnotationHub()

# search for all EuPathDB resources
meta <- query(ah, "EuPathDB")

length(meta)

head(meta)

# types of EuPathDB data available
table(meta$rdataclass)

# distribution of resources by specific databases
table(meta$dataprovider)

# list of organisms for which resources are available
length(unique(meta$species))

head(unique(meta$species))
```

### Query EuPathDb OrgDb resource for *Trypanosoma brucei*

```{r eval=FALSE}
res <- query(ah, c('Trypanosoma brucei brucei TREU927', 'OrgDb', 'EuPathDB'))
res

# retrieve records with one of the ids given
orgdb <- res[['AH72083']]
```

EuPathDB has an issue that's been resolved which involves the inability to download resources by querying the database. The issue is has been reported here: https://support.bioconductor.org/p/121979/. Therefore, annotation packages for *T. brucei* cannot be created using `AnnotationHub` at the moment. However, we can use the scripts here (https://github.com/elsayed-lab/eupathdb-organismdb) to create the package by following the instructions outlined in the repo's README.


After creating and installing the annotation package in R, we perform functional annotation/enrichment (GO and KEGG).
Code from the following repo will be used in functional enrichment analysis: https://github.com/elsayed-lab/manuscript-shared-rnaseq

## Gene ID and Transcript ID
```{r eval=FALSE}
gtf_file <- import("../data/TriTrypDB-43_TbruceiTREU927.gtf")

gene_and_transcript_id <- mcols(gtf_file)[,c("gene_id","transcript_id")]

gene_and_transcript_id <- unique(gene_and_transcript_id)


# replace transcript id with gene ids as rownames
logcpm.norm.counts.combat.tmp <- tibble::rownames_to_column(as.data.frame(logcpm.norm.counts.combat), "transcript_id")

logcpm.norm.counts.combat.tmp$gene_id <- gene_and_transcript_id$gene_id[match(logcpm.norm.counts.combat.tmp$transcript_id, gene_and_transcript_id$transcript_id)]

logcpm.norm.counts.combat <- as.data.frame(logcpm.norm.counts.combat.tmp) %>% remove_rownames %>% column_to_rownames(var = "gene_id")

logcpm.norm.counts.combat$transcript_id <- NULL
```

## Loading annotations from the packages

Document: manuscript-shared-rnaseq/Rmd/init/load_pathogen_annotations.Rmd

```{r eval=FALSE}
#################################################################
# load gene annotations from packages
#################################################################
orgdb <- get("Trypanosoma.brucei.TREU927")

# Fix AnnotationDbi namespace mess
assign('select', dplyr::select, envir=.GlobalEnv)
assign('get',    base::get, envir=.GlobalEnv)

gene_info <- load_parasite_annotations(orgdb, rownames(logcpm.norm.counts.combat),
                                       keytype="GID")

# Get transcript lengths (sum of all exon lengths for each gene)
txdb <- orgdb@txdbSlot
transcript_lengths <- transcriptLengths(txdb)
transcript_lengths <- transcript_lengths[transcript_lengths$gene_id %in%
                                         gene_info$gene_id,]

gene_info[match(transcript_lengths$gene_id, gene_info$gene_id), 
          'transcript_length'] <- transcript_lengths$tx_len
gene_info$transcript_length <- as.numeric(gene_info$transcript_length)

# A gene was excluded in the annotation database as a result of an orphan transcript. Add its placeholder.
## ---not run---
gene_info <- rbind(gene_info, data.frame(gene_id='Tb927.4.4663',
                                         chromosome='4',
                                         description=NA, strand=NA, type=NA,
                                         transcript_length=NA))
  
  
# Keep only the feature information remaining genes
gene_info <- gene_info[gene_info$gene_id %in% rownames(logcpm.norm.counts.combat),] #WGCNA input counts?

# For now, just grab the description for the first transcript
#gene_info <- gene_info[!duplicated(gene_info$gene_id),]

# Gene IDs
gene_ids <- rownames(logcpm.norm.counts.combat)

# gene annotations preview
kable(head(gene_info), caption='Preview of gene annotations.')

#########################################################################################
# load GO terms associated with each parasite gene that were downloaded from Tritrypdb
#########################################################################################
# T. brucei go term annotations file path
#go_term_mapping <- "~/tbrucei_annotation_package/build/3.6.0/TriTrypDB-43_TbruceiTREU927_go_table.txt"
#go_terms <- read.table(go_term_mapping, header = TRUE)

# load go terms from annotation package instead
go_terms <- load_go_terms(orgdb, rownames(logcpm.norm.counts.combat), 
                          keytype='GID')

# Exclude genes not found in count table --not run--
#go_terms <- go_terms[go_terms$GID %in% rownames(logcpm.norm.counts.combat),]

# gene / go term mapping
gene_go_mapping <- as.data.frame(unique(go_terms %>% select(GID, GO, ONTOLOGY)))
colnames(gene_go_mapping) <- c('gene', 'category', 'ontology')

# go id / term mapping
go_term_id_mapping <- as.data.frame(unique(go_terms[c('GO', 'TERM', 'ONTOLOGY')]))
colnames(go_term_id_mapping) <- c("category", "term", "ontology")

#########################################################################################
# Load KEGG annotations
#########################################################################################

gene_kegg_mapping <- load_kegg_mapping(orgdb, rownames(logcpm.norm.counts.combat),
                                       keytype="GID")

kegg_pathways <- load_kegg_pathways(orgdb, rownames(logcpm.norm.counts.combat),
                                    keytype="GID")


# Rename gene/KEGG mapping columns to be consistent with GO mapping
colnames(gene_kegg_mapping) <- c('gene', 'category')
colnames(kegg_pathways)     <- c('category', 'name', 'class', 'description')

kegg_pathways <- unique(kegg_pathways)

```


## GO Enrichment
document: manuscript-shared-rnaseq/Rmd/results/go_enrichment_network.Rmd

```{r gene_lengths_network}
# Redefine gene lengths in case DE enrichment was not run
gene_ids <- gene_info$gene_id

# Create gene lengths vector
gene_lengths <- gene_info$transcript_length
names(gene_lengths) <- gene_info$gene_id
```

```{r go_enrichment_modules, message=FALSE, warning=FALSE, results='hide', cache=CONFIG$use_cache, autodep=TRUE, eval=CONFIG$module_enrichment}
# save required variables obtained earlier in 
# analysis with variable names of the code below
module_colors <- module.colours
gene_tree <-gene.tree
wgcna_input <- logcpm.norm.counts.combat
modules_of_interest <- interesting.modules
num_modules <- length(unique(module_colors))

# Initialize parallelization
cl <- makeCluster(max(1, min(10, detectCores() - 2, na.rm = TRUE)))
registerDoParallel(cl)
message("Performing GO enrichment")

# Check each module for enrichment in GO terms and save result in a list
module_go_enrichment <- foreach(color=unique(module_colors), .packages=c('goseq')) %dopar% {
  set.seed(1)
  # Measure GO enrichment for module
  enriched <- tryCatch({
    # module gene ids
    in_module_geneids <- gene_ids[module_colors == color]
    message(sprintf("[GO enrichment] %s", color))
    
    # T. brucei GO enrichment
    enriched <- test_gene_enrichment(in_module_geneids, gene_ids,
                                          gene_go_mapping, gene_lengths)
    
    # Add descriptions
    enriched <- merge(enriched, go_term_id_mapping, by='category')
  }, error=function(e) {
    # goseq fails in some cases; have not been able to track down cause yet
    # to avoid errors we will just return an empty result set
    warning(sprintf("GO enrichment failed for module %s", color))
    cbind(
        get_enrichment_placeholder(),
        term=numeric(0),
        ontology=numeric(0)
    )
  })
  enriched
}
names(module_go_enrichment) <- unique(module_colors)

# remove any null/empty entries from the results
module_go_enrichment <- module_go_enrichment[!sapply(module_go_enrichment, is.null)]

# unregister cpus
stopCluster(cl)
```

```{r print_go_enrichment_modules, results='asis', eval=CONFIG$module_enrichment}
# Print enrichment results
tmp <- cbind(gene=gene_ids, color=module_colors)
gene_mapping <- merge(gene_go_mapping, tmp, by='gene')
cat(sprintf('- Total enriched modules: %d\n', 
            sum(sapply(module_go_enrichment, nrow) > 0)))

# create tables of the results in this document
print_enrichment_results(module_go_enrichment, module_sizes, 'GO terms',
                             #NULL, gene_mapping, 'output/modules', 
                             NULL, gene_mapping, 
                             enrichment_type='go',
                             include_gene_lists=FALSE)

enriched_colors_go <- get_enriched_modules(module_go_enrichment)

# Module enrichment status (used in dendrogram plots)
go_enrichment_status   <- as.numeric(module_colors %in% enriched_colors_go)

```


## KEGG Enrichment

document: manuscript-shared-rnaseq/Rmd/results/kegg_enrichment_network.Rmd

```{r kegg_enrichment_modules, message=FALSE, warning=FALSE, results='hide', cache=CONFIG$use_cache, autodep=TRUE}
# Check each module for enrichment in KEGG terms and save result in a list
cl <- makeCluster(max(1, min(10, detectCores() - 2, na.rm = TRUE)))
registerDoParallel(cl)

message("Performing KEGG enrichment")

# Check each module for enrichment in GO terms and save result in a list
module_kegg_enrichment <- foreach(color=unique(module_colors), .packages=c('goseq')) %dopar% {
  set.seed(1)

  # Measure KEGG enrichment for module
  enriched <- tryCatch({
      in_module_geneids <- gene_ids[module_colors == color]
      enriched <- test_gene_enrichment(in_module_geneids, gene_ids,
                                        gene_kegg_mapping, gene_lengths)
      
      enriched <- unique(merge(enriched, kegg_pathways[,c('category','name')],
                              by='category'))
  }, error=function(e) {
      # goseq fails in some cases; have not been able to track down cause yet
      warning(sprintf("KEGG enrichment failed for module %s", color))
      return(get_enrichment_placeholder())
  })
  enriched
}

names(module_kegg_enrichment) <- unique(module_colors)

# remove any null/empty entries from the results
module_kegg_enrichment <- module_kegg_enrichment[!sapply(module_kegg_enrichment, is.null)]

# unregister cpus
stopCluster(cl)
```

```{r print_kegg_enrichment_modules, results='asis'}
cat(sprintf('- Total enriched modules: %d\n', 
            sum(sapply(module_kegg_enrichment, nrow) > 0)))

# create tables of the results in this document
print_enrichment_results(module_kegg_enrichment, module_sizes, 
                             'KEGG pathway',
                             #output_dir='output/modules',
                             enrichment_type='kegg')

enriched_colors_kegg <- get_enriched_modules(module_kegg_enrichment)

```

```{r enrichment_status}
# Module enrichment status (used in dendrogram plots)
kegg_enrichment_status <- as.numeric(module_colors %in% enriched_colors_kegg)
```

```{r module_dendrogram_annotated, results='asis', echo=CONFIG$include_plots, eval=CONFIG$include_plots}

cat('\n### Dendrogram with annotated modules\n')

unassigned_modules <- as.numeric(module_colors == 'grey')

png(filename = "../figures/gene_tree_and_module_enrichment_status.png", res =1200, type = "cairo", units = 'in', width = 5, height = 6, pointsize = 10)
WGCNA::plotDendroAndColors(gene_tree,
                        cbind(module_colors, go_enrichment_status,
                            kegg_enrichment_status, unassigned_modules),
                        groupLabels=c(sprintf("Modules\n(n=%s)", num_modules),
                                    #sprintf("Red = upregulated at %s", CONFIG$de_cond2),
                                    "GO enrichment", "KEGG enrichment", "Unassigned"),
                        #cex.colorLabels=cex_color_labels, cex.main=cex_main,
                       # cex.axis=cex_axis, cex.lab=cex_lab,
                        dendroLabels=FALSE,
                        #marAll=c(4,8,6,4),
                        guideHang=0.05)
dev.off()
```

\newpage
```{r fig.cap="Gene tree and module enrichment status", echo=FALSE, out.width='80%'}

include_graphics("../figures/gene_tree_and_module_enrichment_status.png")
```

# Module labels mappings
```{r eval=FALSE}
module_label_mapping <- rbind(cbind(modules_of_interest,
                                    seq_along(modules_of_interest)),
                              cbind(remaining_modules, #remaining modules variable?
                                    seq_along(remaining_modules) +
                                      length(modules_of_interest)))

module_label_mapping <- as.data.frame(module_label_mapping)
colnames(module_label_mapping) <- c('color', 'number')
```


## Save results

```{r}
## Save results

###############################################################################
# Save enrichment results as text files
module_output_dir <- "../results/enrichment_results"
if (!dir.exists(module_output_dir)) {
    dir.create(module_output_dir, recursive=TRUE)
}

# GO enrichment 
output_module_enrichment_results(module_go_enrichment, module_output_dir,
'go', go_term_id_mapping)

# KEGG enrichment
output_module_enrichment_results(module_kegg_enrichment, module_output_dir,
'kegg', kegg_pathways %>% select(-description))

#################################################################################
# Create result data frame
result <- cbind(gene_info, color=module_colors)

# drop unneeded columns
keep_cols <- intersect(c('gene_id', 'color', 'description', 'chromosome',
'strand', 'transcript_length'), colnames(result))
result <- tbl_df(result[,keep_cols])

# add expression-related fields
result$expr_variance <- apply(wgcna_input, 1, var)
result$expr_mean <- apply(wgcna_input, 1, mean)

# replace colors with numbers
#module_colors <- module_label_mapping$number[match(module_colors, module_label_mapping$color)]

#result$color <- module_label_mapping$number[match(result$color, module_label_mapping$color)]

# Write out an excel/csv file for the result dataframe
write.table(result, file="../results/results_df.txt", quote = FALSE, sep = "\t")

#################################################################################
correlation_matrix <- cor(network.counts) # check this further to determine whether relationship is correct

# Module Stats
# main_contrast: variable useful if 'result' variable has Differential expression column specified
# "de_comparisons"
#--this code did not work--
module_stats <- create_module_stats_df(result, correlation_matrix, 
                                       wgcna_input,main_contrast)

# Write module stats to a file
write.csv(module_stats, file="../results/module_stats.csv",row.names=FALSE, quote=FALSE)

```



## Gene developmental stage associations

document: manuscript-shared-rnaseq/Rmd/main/network_module_detection.Rmd

## Dendrogram with differential expression status

document: manuscript-shared-rnaseq/Rmd/main/network_module_detection.Rmd

## Expression profiles: gene grouping based on sub-groups and selected co-expression modules.

* Research paper supplementary file. 
* document: manuscript-shared-rnaseq/Rmd/results/expression_profiles.Rmd - combine replicates.

## Write out results files.

* Research paper supplementary files.






