---
title: "Functional Annotation Analysis for *T. brucei* RNA-seq data"
author: "Kennedy Mwangi"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r echo=FALSE}
# required package
# library('AnnotationHub')
library('foreach')
library('doParallel')
library('Trypanosoma.brucei.TREU927', character.only = TRUE)


# load helper functions
source("~/manuscript-shared-rnaseq/R/enrichment_analysis.R")
source("~/manuscript-shared-rnaseq/R/annotations.R")
```

## Introduction
This document holds code to try out different criterias of functional annotation before incorporation in the main pipeline. It uses online tutorials listed below.

## Resources

- https://bioconductor.org/packages/devel/data/annotation/vignettes/EuPathDB/inst/doc/EuPathDB.html
- http://bioconductor.org/packages/release/bioc/vignettes/AnnotationHub/inst/doc/AnnotationHub-HOWTO.html
- https://bioconductor.org/packages/devel/bioc/vignettes/goseq/inst/doc/goseq.pdf

## Analysis

### Getting started

```{r eval=FALSE}
# create an AnnotationHub connection
ah <- AnnotationHub()

# search for all EuPathDB resources
meta <- query(ah, "EuPathDB")

length(meta)

head(meta)

# types of EuPathDB data available
table(meta$rdataclass)

# distribution of resources by specific databases
table(meta$dataprovider)

# list of organisms for which resources are available
length(unique(meta$species))

head(unique(meta$species))
```

### Query EuPathDb OrgDb resource for *Trypanosoma brucei*

```{r eval=FALSE}
res <- query(ah, c('Trypanosoma brucei brucei TREU927', 'OrgDb', 'EuPathDB'))
res

# retrieve records with one of the ids given
orgdb <- res[['AH72083']]
```

EuPathDB has an issue that's been resolved which involves the inability to download resources by querying the database. The issue is has been reported here: https://support.bioconductor.org/p/121979/. Therefore, annotation packages for *T. brucei* cannot be created using `AnnotationHub` at the moment. However, we can use the scripts here (https://github.com/elsayed-lab/eupathdb-organismdb) to create the package by following the instructions outlined in the repo's README.


After creating and installing the annotation package in R, we perform functional annotation/enrichment (GO and KEGG).
Code from the following repo will be used in functional enrichment analysis: https://github.com/elsayed-lab/manuscript-shared-rnaseq


## Loading annotations from the packages

Document: manuscript-shared-rnaseq/Rmd/init/load_pathogen_annotations.Rmd

```{r eval=FALSE}
#################################################################
# load gene annotations from packages
#################################################################
orgdb <- get(Trypanosoma.brucei.TREU927)

# Fix AnnotationDbi namespace mess
assign('select', dplyr::select, envir=.GlobalEnv)
assign('get',    base::get, envir=.GlobalEnv)

gene_info <- load_parasite_annotations(orgdb, rownames(counts$counts),
                                       keytype="GID") # Warning: counts object contains transcript names instead of genes names. Use gene names instead.

# Get transcript lengths (sum of all exon lengths for each gene)
txdb <- orgdb@txdbSlot
transcript_lengths <- transcriptLengths(txdb)
transcript_lengths <- transcript_lengths[transcript_lengths$gene_id %in%
                                         gene_info$gene_id,]

gene_info[match(transcript_lengths$gene_id, gene_info$gene_id), 
          'transcript_length'] <- transcript_lengths$tx_len
gene_info$transcript_length <- as.numeric(gene_info$transcript_length)

# A gene was excluded in the annotation database as a result of an orphan transcript. Add its placeholder.
  gene_info <- rbind(gene_info,
                     data.frame(gene_id='Tb927.4.4663',
                                chromosome='4',
                                description=NA, strand=NA, type=NA, 
                                transcript_length=NA))
  
  
# Keep only the feature information remaining genes
gene_info <- gene_info[gene_info$gene_id %in% rownames(counts$counts),] #WGCNA input counts table?

# For now, just grab the description for the first transcript
#gene_info <- gene_info[!duplicated(gene_info$gene_id),]

# Gene IDs
gene_ids <- rownames(counts$counts)

# gene annotations preview
kable(head(gene_info), caption='Preview of gene annotations.')

#########################################################################################
# load GO terms associated with each parasite gene that were downloaded from Tritrypdb
#########################################################################################
# T. brucei go term annotations file path
go_term_mapping <- "~/tbrucei_annotation_package/build/3.6.0/TriTrypDB-43_TbruceiTREU927_go_table.txt"
go_terms <- read.table(go_term_mapping, header = TRUE)

# Exclude genes not found in count table
go_terms <- go_terms[go_terms$gene %in% rownames(counts$counts),]

# gene / go term mapping
gene_go_mapping <- as.data.frame(unique(go_terms %>% select(-term)))

# go id / term mapping
go_term_id_mapping <- as.data.frame(unique(go_terms %>% select(-gene)))

#########################################################################################
# Load KEGG annotations
#########################################################################################

gene_kegg_mapping <- load_kegg_mapping(orgdb, rownames(counts$counts),
                                       keytype="GID")

kegg_pathways <- load_kegg_pathways(orgdb, rownames(counts$counts),
                                    keytype="GID")


# Rename gene/KEGG mapping columns to be consistent with GO mapping
colnames(gene_kegg_mapping) <- c('gene', 'category')
colnames(kegg_pathways)     <- c('category', 'name', 'class', 'description')

kegg_pathways <- unique(kegg_pathways)

```



## GO Enrichment
document: manuscript-shared-rnaseq/Rmd/results/go_enrichment_network.Rmd

```{r gene_lengths_network}
# Redefine gene lengths in case DE enrichment was not run
gene_ids <- gene_info$gene_id

# Create gene lengths vector
gene_lengths <- gene_info$transcript_length
names(gene_lengths) <- gene_info$gene_id
```

```{r go_enrichment_modules, message=FALSE, warning=FALSE, results='hide', cache=CONFIG$use_cache, autodep=TRUE, eval=CONFIG$module_enrichment}
# save required variables obtained earlier in 
# analysis with variable names of the code below
module_colors <- module.colours
gene_tree <-gene.tree

# Initiallize parallelization
cl <- makeCluster(max(1, min(10, detectCores() - 2, na.rm = TRUE)))
registerDoParallel(cl)
message("Performing GO enrichment")

# Check each module for enrichment in GO terms and save result in a list
module_go_enrichment <- foreach(color=unique(module_colors), .packages=c('goseq')) %dopar% {
  set.seed(1)
  # Measure GO enrichment for module
  enriched <- tryCatch({
    # module gene ids
    in_module_geneids <- gene_ids[module_colors == color]
    message(sprintf("[GO enrichment] %s", color))
    
    # T. brucei GO enrichment
    enriched <- test_gene_enrichment(in_module_geneids, gene_ids,
                                          gene_go_mapping, gene_lengths)
    
    # Add descriptions
    #enriched <- merge(enriched, go_term_id_mapping, by='category')
  }, error=function(e) {
    # goseq fails in some cases; have not been able to track down cause yet
    # to avoid errors we will just return an empty result set
    warning(sprintf("GO enrichment failed for module %s", color))
    cbind(
        get_enrichment_placeholder(),
        term=numeric(0),
        ontology=numeric(0)
    )
  })
  enriched
}
names(module_go_enrichment) <- unique(module_colors)

# remove any null/empty entries from the results
module_go_enrichment <- module_go_enrichment[!sapply(module_go_enrichment, is.null)]

# unregister cpus
stopCluster(cl)
```

```{r print_go_enrichment_modules, results='asis', eval=CONFIG$module_enrichment}
# Print enrichment results
tmp <- cbind(gene=gene_ids, color=module_colors)
gene_mapping <- merge(gene_go_mapping, tmp, by='gene')
cat(sprintf('- Total enriched modules: %d\n', 
            sum(sapply(module_go_enrichment, nrow) > 0)))

# create tables of the results in this document
print_enrichment_results(module_go_enrichment, module_sizes, 'GO terms',
                             #NULL, gene_mapping, 'output/modules', 
                             NULL, gene_mapping, 
                             enrichment_type='go',
                             include_gene_lists=FALSE)

enriched_colors_go <- get_enriched_modules(module_go_enrichment)

# Module enrichment status (used in dendrogram plots)
go_enrichment_status   <- as.numeric(module_colors %in% enriched_colors_go)

```


## KEGG Enrichment

document: manuscript-shared-rnaseq/Rmd/results/kegg_enrichment_network.Rmd

```{r kegg_enrichment_modules, message=FALSE, warning=FALSE, results='hide', cache=CONFIG$use_cache, autodep=TRUE}
# Check each module for enrichment in KEGG terms and save result in a list
cl <- makeCluster(max(1, min(10, detectCores() - 2, na.rm = TRUE)))
registerDoParallel(cl)

message("Performing KEGG enrichment")

# Check each module for enrichment in GO terms and save result in a list
module_kegg_enrichment <- foreach(color=unique(module_colors), .packages=c('goseq')) %dopar% {
  set.seed(1)

  # Measure KEGG enrichment for module
  enriched <- tryCatch({
      in_module_geneids <- gene_ids[module_colors == color]
      enriched <- test_gene_enrichment(in_module_geneids, gene_ids,
                                        gene_kegg_mapping, gene_lengths)
      
      enriched <- unique(merge(enriched, kegg_pathways[,c('category','name')],
                              by='category'))
  }, error=function(e) {
      # goseq fails in some cases; have not been able to track down cause yet
      warning(sprintf("KEGG enrichment failed for module %s", color))
      return(get_enrichment_placeholder())
  })
  enriched
}

names(module_kegg_enrichment) <- unique(module_colors)

# remove any null/empty entries from the results
module_kegg_enrichment <- module_kegg_enrichment[!sapply(module_kegg_enrichment, is.null)]

# unregister cpus
stopCluster(cl)
```

```{r print_kegg_enrichment_modules, results='asis'}
cat(sprintf('- Total enriched modules: %d\n', 
            sum(sapply(module_kegg_enrichment, nrow) > 0)))

# create tables of the results in this document
print_enrichment_results(module_kegg_enrichment, module_sizes, 
                             'KEGG pathway',
                             #output_dir='output/modules',
                             enrichment_type='kegg')

enriched_colors_kegg <- get_enriched_modules(module_kegg_enrichment)

```

```{r enrichment_status}
# Module enrichment status (used in dendrogram plots)
kegg_enrichment_status <- as.numeric(module_colors %in% enriched_colors_kegg)
```

```{r module_dendrogram_annotated, results='asis', echo=CONFIG$include_plots, eval=CONFIG$include_plots}

cat('\n### Dendrogram with annotated modules\n')

unassigned_modules <- as.numeric(module_colors == 'grey')

png(filename = "../figures/gene_tree_and_module_enrichment_status.png", res =1200, type = "cairo", units = 'in', width = 5, height = 6, pointsize = 10)
WGCNA::plotDendroAndColors(gene_tree,
                        cbind(module_colors, go_enrichment_status,
                            kegg_enrichment_status, unassigned_modules),
                        groupLabels=c(sprintf("Modules\n(n=%s)", num_modules),
                                    #sprintf("Red = upregulated at %s", CONFIG$de_cond2),
                                    "GO enrichment", "KEGG enrichment", "Unassigned"),
                        cex.colorLabels=cex_color_labels, cex.main=cex_main,
                        cex.axis=cex_axis, cex.lab=cex_lab,
                        dendroLabels=FALSE,
                        marAll=c(4,8,6,4),
                        guideHang=0.05)
dev.off()
```

\newpage
```{r fig.cap="Gene tree and module enrichment status", echo=FALSE, out.width='80%'}

include_graphics("../figures/gene_tree_and_module_enrichment_status.png")
```

## Gene developmental stage associations

document: manuscript-shared-rnaseq/Rmd/main/network_module_detection.Rmd

## Dendrogram with differential expression status

document: manuscript-shared-rnaseq/Rmd/main/network_module_detection.Rmd

## Expression profiles: gene grouping based on sub-groups and selected co-expression modules.

* Research paper supplementary file. 
* document: manuscript-shared-rnaseq/Rmd/results/expression_profiles.Rmd - combine replicates.

## Write out results files.

* Research paper supplementary files.






