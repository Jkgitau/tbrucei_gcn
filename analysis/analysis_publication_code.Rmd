---
title: "*Trypanosoma brucei* co-expression network analysis"
author: "Kennedy Mwangi"
date: "September 13, 2020"
output:
  pdf_document: default
  html_document: default
editor_options: 
  chunk_output_type: inline
---

```{r include=FALSE}
library("knitr")
opts_chunk$set(echo = TRUE, 
                      fig.pos = 'h', 
                      fig.align = 'center', 
                      fig.show='hold')
load("sample.metdata.final.RData")
```
## Introduction
This document contains the workflow used in the analysis of *T. brucei* gene co-expression network analysis. It contains code used in each step of the analysis. The code and output files are archived at https://github.com/wanjauk/tbrucei_gcn

### Setting up R for the analysis

```{r, code = readLines(here::here("scripts","00_libraries.R")), eval=FALSE}

```

```{r, code = readLines(here::here("scripts","01_settings.R")), eval=FALSE}

```

## Data acquisition
Data used in this study is obtained from European Nucleotide Archive under accession number SRP002243 and SRR965341.

First, metadata for the data is obtained from EBI as follows:

```{r, code = readLines(here::here("scripts","02a_download-metadata-file.R")), eval=FALSE}

```

```{r, eval=TRUE, echo=TRUE}
# print out the sample metadata table
sample.metadata
```


Next, RNASeq data is downloaded from EBI database's FTP site. Some of the downstream tools require that FASTQ files that were downloaded in zipped form are unzipped.

```{bash, code = readLines(here::here("scripts","02b_download-fastq-files.sh")), eval=FALSE}

```

## Downloading *T. brucei* and *G. morsitans* genome and annotation files

Genomes are obtained from their respective databases before alignment. The genome and annotation files are downloaded from the TriTrypDB and vectorbase databases as follows:

```{bash, code = readLines(here::here("scripts","02c_download-genome-and-annotation-files.sh")), eval=FALSE}

```

## Data quality assessment
After downloading the RNASeq data, its quality is checked through the FASTQC tool whose output is a report in HTML format.

```{bash, code = readLines(here::here("scripts","03_generate-fastqc-reports.sh")), eval=FALSE}

```

Following the high rate of duplicate reads after FASTQC analysis, further analysis is done to ascertain their cause. Duplicate reads are assessed whether they arise from artifacts in PCR (PCR duplicates) or from biological causes (highly expressed genes). This is done later in the analysis after read mapping. 

```{r echo=FALSE, out.width='80%', eval=FALSE}
include_graphics("../figures/fastqc_sequence_duplication_levels_plot.png")
```

### Concatenate and index the *T. brucei* and *G. morsitans* genome files

*T. brucei* and *G. morsitans* genome files are concatenated into a single fasta file which is used during the alignment of the reads. This ensures no cross-mapping of reads take place during alignment with HISAT2. The next step is indexing the genome using HISAT2.

```{bash, code = readLines(here::here("scripts","04_concatenate-and-index-genome.sh")), eval=FALSE}

```


### Aligning the reads to the genome (Read Mapping)

Alignment of the reads to the chimeric genome. The output is SAM files.


```{bash, code = readLines(here::here("scripts","05_read-alignment.sh")), eval=FALSE}

```
 

```{r echo=FALSE, out.width='80%', eval=FALSE}
#Below is the alignment results from HISAT2 alignment tool.
include_graphics("../figures/hisat2_se_plot.png")
```

## Assessment of the duplication rate
At this point, quality control to assess the duplication rate can be performed.
First, the SAM files are converted to sorted BAM files required by dupRadar tool. The BAM files are then sorted using samtools

```{bash, code = readLines(here::here("scripts","06_convert-sam-to-bam.sh")), eval=FALSE}

```

Next, duplicates are marked in the BAM files using Picard.

```{bash, code = readLines(here::here("scripts","07_mark-duplicates.sh")), eval=FALSE}

```

```{r echo=FALSE, eval=FALSE}

Before this quality control can be performed, we need to verify whether the reads are stranded or not as this is a required parameter for dupRadar as well as HTSeq tool later in the analysis. This can be done using RSeQC package - An RNA-seq Quality Control Package. `infer_experiment.py` module is used in this case. RSeQC documentation and tutorial can be found [here](http://rseqc.sourceforge.net/).

First we convert *T. brucei* genome annotation GTF file into `bed` format required by RSeQC package. Then we use `infer_experiment.py` to verify strandedness using a few samples.

#```{bash, eval=FALSE, engine="sh"}
# convert GTF genome annotation to BED format using a custom script from:
#https://github.com/ExpressionAnalysis/ea-utils/tree/master/clipper

../scripts/gtf2bed.pl ../data/tbrucei_genome_annotations_GTF/TriTrypDB-43_TbruceiTREU927.gtf > \
../data/tbrucei_genome_annotations_GTF/TriTrypDB-43_TbruceiTREU927.bed

infer_experiment.py -i ../data/processed_data/bru-mor_bam/SRR039381.bam \
-r ../data/tbrucei_genome_annotations_GTF/TriTrypDB-43_TbruceiTREU927.bed

# output
#This is SingleEnd Data
#Fraction of reads failed to determine: 0.0008
#Fraction of reads explained by "++,--": 0.3832
#Fraction of reads explained by "+-,-+": 0.6161
#```

The next step is to run the dupRadar quality control analysis setting the `stranded` parameter as `FALSE` as the reads are not strand specific. Tutorial for the tool can be found [here](https://bioconductor.riken.jp/packages/3.5/bioc/vignettes/dupRadar/inst/doc/dupRadar.html)

```


For each of the 18 samples, dupRadar tool is used to perform quality control in R.

```{r, code = readLines(here::here("scripts","08_run-dupRadar.R")), eval=FALSE}

```


```{r fig.cap="Sample without PCR duplicates", echo=FALSE, out.width='80%', eval=FALSE}
#Below are representative plots of samples with PCR duplicates and without PCR duplicates. Samples with PCR duplicates are removed from the analysis before counts data are read into R.

include_graphics("../figures/duplication_rate/SRR039378.png")
```


```{r fig.cap="Sample with PCR duplicates", echo=FALSE, out.width='80%', eval=FALSE}
include_graphics("../figures/duplication_rate/SRR039937.png")
```

Samples that had technical duplicates were excluded from sample metadata and further analysis.

```{r, eval=FALSE, echo=FALSE}

# Exclusion of the following samples was done after analysis showed they
# failed quality control.

# remove 3 samples that have technical duplicates (SRR039951, SRR039937, SRR039938)
sample.metadata <- sample.metadata[-15,]
sample.metadata <- sample.metadata[-9,]
sample.metadata <- sample.metadata[-8,]
```

## Reads quantification

HTSeq tool is used to count reads that aligned to the *T. brucei* genome. *T. brucei* annotation file is used and therefore HTSeq excludes counting *G. morsitans* reads that aligned to *Glossina* genome. The output is a text file for each sample that contains the number of reads that were counted for each gene.

```{bash, code = readLines(here::here("scripts","09_reads-quantification.sh")), eval=FALSE}

```


```{r fig.cap="HTSeq reads assignment", echo=FALSE, out.width='80%', eval=FALSE}
#Below is a graphical visualization of reads assignment by HTSeq.
include_graphics("../figures/htseq_assignment_plot_brucei_only.png")
```


```{bash, eval=FALSE, engine="sh", echo=FALSE }

## Generating MultiQC report

#MultiQC aggregates results from FASTQC, HISAT2 and HTSeq analysis into an HTML formatted single report for better visualization.
#change directory to results
cd ../results

#Run multiqc
multiqc .

# create a directory for the multiQC report and move the output there.
mkdir -p brucei_multiqc_report
mv multiqc* brucei_multiqc_report/
```

## Filtering out non-protein coding genes

Before loading the data into R, filter out the non-protein coding genes which include ncRNA, snRNA, snoRNA, pseudogenic transcripts, rRNA and tRNA.

```{bash, code = readLines(here::here("scripts","10_exclude-features.sh")), eval=FALSE}

```


## Analysis in R

### Importing samples count data into R

For further analysis, samples read counts are read into R. To read the sample counts data into R using the script below, simply type `source(here::here("scripts","11_import-read-counts-into-r.R")` on the R console and hit enter.

```{r, code = readLines(here::here("scripts","11_import-read-counts-into-r.R")), eval=FALSE}

```


### Sample quality check

The quality of the samples is checked before further analysis to check for outlier and batch effects.

```{r, code = readLines(here::here("scripts","12_sample-preprocessing-and-quality-check.R")), eval=FALSE}

```


```{r fig.cap="Raw sample density plot", echo=FALSE, out.width='90%', eval=FALSE}
include_graphics("../figures/raw_sample_density.png")
```

```{r fig.cap="Normalized sample density plot", echo=FALSE, eval=FALSE}

include_graphics("../figures/norm_sample_density.png")
```


```{r fig.cap="Raw Sample PCA", echo=FALSE, eval=FALSE}
include_graphics("../figures/raw_samples_PCA.png")
```

```{r fig.cap="Filtered-Unnormalized sample PCA", echo=FALSE, eval=FALSE}

include_graphics("../figures/unnorm_sample_PCA.png")
```

```{r fig.cap="Normalized sample PCA", echo=FALSE, eval=FALSE}

include_graphics("../figures/norm_sample_PCA.png")
```

```{r fig.cap="Normalized and batch effect removed sample PCA", echo=FALSE, eval=FALSE}

include_graphics("../figures/batch_effect_removal_analysis/combat_norm_sample_PCA.png")
```


```{r fig.cap="Filtered-Unnormalized Sample boxplot", echo=FALSE, out.width='75%',eval=FALSE}
include_graphics("../figures/unnorm_sample_boxplot.png")
```

```{r fig.cap="Normalized sample boxplot", echo=FALSE, out.width='75%', eval=FALSE}

include_graphics("../figures/norm_sample_boxplot.png")
``` 

```{r eval=FALSE, echo=FALSE}
### Identify differentially expressed genes

# Apply sample grouping based on Tissue from which the sample was derived
design <- model.matrix(~0+sample.metadata$Tissue+sample.metadata$Batch)
#colnames(design) <- levels(sample.metadata$Tissue)
colnames(design) <- c("MG","PV","SG","Batch")

# Estimate dispersions for tags
filtered.counts.dge <- estimateDisp(filtered.counts, design, robust = TRUE)

# Fit a generalized likelihood model to the DGELIST using sample grouping
fit <- glmFit(filtered.counts.dge,design)

#################################################################
# code in this section adapted from https://github.com/iscb-dc-rsg/2016-summer-workshop
# generate a list of all possible pairwise contrasts
condition_pairs <- t(combn(levels(sample.metadata$Tissue), 2))

comparisons <- list()
for (i in 1:nrow(condition_pairs)) {
  comparisons[[i]] <- as.character(condition_pairs[i,])
}

# remove MG to SG comparison
comparisons[[2]] <- NULL

# vector to store differentially expressed genes
sig_genes <- c()

# iterate over the contrasts, and perform a differential expression test for
# each pair
for (conds in comparisons) {
    # generate string contrast formula
    contrast_formula <- paste(conds, collapse=' - ')

    contrast_mat <- makeContrasts(contrasts=contrast_formula, levels=design)
    contrast_lrt <- glmLRT(fit, contrast=contrast_mat)
    topGenes <- topTags(contrast_lrt, n=Inf, p.value=0.05, adjust.method = "BH")
    
    # Grab highly ranked genes
    sig_genes <- union(sig_genes, rownames(topGenes$table))
}

# Filter out genes which were not differentially expressed for any contrast
de.genes <- filtered.counts.dge[rownames(filtered.counts.dge) %in% sig_genes,]
dim(de.genes$counts)
#3934   15
################################################################

# Obtain the counts of genes expressed for each contrast individually
# This aims to obtain the number of genes differentially expressed between 
# the 3 stages of development i.e. MG -> PV, PV -> SG

# Likelihood ratio test to identify DEGs
# SG compared to PV
  SG_vs_PV_lrt <- glmLRT(fit, contrast=c(0,-1,1,0))

# PV compared to MG
PV_vs_MG_lrt <- glmLRT(fit, contrast = c(-1,1,0,0))


# Genes with most significant differences (using topTags)
# SG compared to PV
topGenes_SG <- topTags(SG_vs_PV_lrt, adjust.method = "BH", p.value = 0.05, n=Inf)
dim(topGenes_SG)
#3166    5

# PV compared to MG
topGenes_PV <- topTags(PV_vs_MG_lrt, adjust.method = "BH", p.value = 0.05, n=Inf)
dim(topGenes_PV)
#1908    5

#Total number of genes: 5074
#######################################################################################
# DE genes at 5% FDR (using decideTestsDGE function)
#
# SG compared to PV
SG_vs_PV_de.genes <- decideTestsDGE(SG_vs_PV_lrt, adjust.method = "BH", p.value = 0.05)

# get summary
summary(SG_vs_PV_de.genes)
#       -1*PV 1*SG
#Down         1463
#NotSig       4224
#Up           1703

# PV compared to MG
PV_vs_MG_de.genes <- decideTestsDGE(PV_vs_MG_lrt, adjust.method = "BH", p.value = 0.05)

# summary
summary(PV_vs_MG_de.genes)
#       -1*MG 1*PV
#Down         987
#NotSig       5482
#Up           921

# DE genes in the PV that are common in both comparisons
de.common <- which(PV_vs_MG_de.genes[,1]!=0 & SG_vs_PV_de.genes[,1]!=0)
length(de.common)
#1140 

de.common.df <- as.data.frame(de.common)
de.common.df <- tibble::rownames_to_column(de.common.df, var = "gene_id")

# create a dataframe with data on PV and SG differential gene expression
PV_data <- topGenes_PV$table
SG_data <- topGenes_SG$table

PV_data <- tibble::rownames_to_column(PV_data, var = "gene_id")
SG_data <- tibble::rownames_to_column(SG_data, var = "gene_id")

# obtain the common genes for each comparison
PV_data_common_de_genes <- PV_data %>% filter(gene_id %in% de.common.df$gene_id)
SG_data_common_de_genes <- SG_data %>% filter(gene_id %in% de.common.df$gene_id)

PV_data_common_de_genes <- PV_data_common_de_genes[order(PV_data_common_de_genes$logFC, 
                                                         decreasing = TRUE),]
SG_data_common_de_genes <- SG_data_common_de_genes[order(SG_data_common_de_genes$logFC, 
                                                         decreasing = TRUE),]

# write out to excel upregulated and downregulated genes and the commmon genes between contrasts
PV_vs_MG <- PV_data[order(PV_data$logFC, decreasing = TRUE),]
SG_vs_PV <- SG_data[order(SG_data$logFC, decreasing = TRUE),]

write.xlsx(PV_vs_MG, file = "../results/differentially_expressed_genes.xlsx",
           sheetName = "MG vs PV", row.names = FALSE)
write.xlsx(SG_vs_PV, file = "../results/differentially_expressed_genes.xlsx",
           sheetName = "PV vs SG", append = TRUE, row.names = FALSE)

write.xlsx(PV_data_common_de_genes, 
           file = "../results/differentially_expressed_genes_common_in_contrasts.xlsx",
           sheetName = "MG vs PV Common genes", append = TRUE, row.names = FALSE)
write.xlsx(SG_data_common_de_genes, 
           file = "../results/differentially_expressed_genes_common_in_contrasts.xlsx",
           sheetName = "PV vs SG Common genes", append = TRUE, row.names = FALSE)

PV_contrast_common_de_genes_logFC <- PV_data_common_de_genes %>% select(gene_id, logFC_MGvsPV=logFC)

SG_contrast_common_de_genes_logFC <- SG_data_common_de_genes %>% select(gene_id, logFC_PVvsSG=logFC)

contrast_common_de_genes_logFC <- merge(PV_contrast_common_de_genes_logFC, 
                                        SG_contrast_common_de_genes_logFC, by="gene_id")

write.xlsx(contrast_common_de_genes_logFC, 
           file = "../results/differentially_expressed_genes_common_in_contrasts_logFC_comparison.xlsx",
           sheetName = "Common DEGs LogFC Comparisons", row.names = FALSE)

```



```{r, eval=FALSE, echo=FALSE}
# Plotting to visually inspect differential gene expression results.

# Differential expression analysis - plots
#
# Volcano plots
SG_DEGs <- topGenes_SG$table

SG_DEGs <- tibble::rownames_to_column(SG_DEGs, var = "gene_id")

SG_DEGs = mutate(SG_DEGs, sig=ifelse(SG_DEGs$FDR <0.05 & abs(logFC)>1, "FDR<0.05", "Not Sig"))

#png("../figures/ggplot_SG-PV_DEG_volcanoplot.png", res =1200, type = "cairo", units = 'in',
#    width = 6, height = 6, pointsize = 4)
ggplot(SG_DEGs, 
  aes(logFC, -log10(PValue))) +
  geom_point(aes(col=sig),size = 1) + 
  theme_bw(base_size = 9) + 
    #coord_cartesian(ylim=c(0,300))+ 
  coord_cartesian(xlim=c(-10,13)) +
  scale_color_manual(values=c("red","black")) +
  ggtitle("SG vs PV differentially expressed genes") +
  geom_text_repel(data=filter(SG_DEGs, logFC>4.5 | logFC< -3.7),
                  #family = "Times New Roman", 
                  aes(label=gene_id),
                  #size = 2, 
                  arrow = arrow(length = unit(0.01, 'npc')), 
                  force = 7,box.padding = unit(0.4, "lines"), 
                  point.padding = unit(0.3, "lines"))
ggsave("../figures/SG-PV_DEG_volcanoplot.png", device = "png")

#dev.off()
###################################
PV_DEGs <- topGenes_PV$table

PV_DEGs <- tibble::rownames_to_column(PV_DEGs, var = "gene_id")

PV_DEGs = mutate(PV_DEGs, sig=ifelse(PV_DEGs$FDR <0.05 & abs(logFC)>1, "FDR<0.05", "Not Sig"))

ggplot(PV_DEGs, 
       aes(logFC, -log10(PValue))) +
  geom_point(aes(col=sig),size = 1) + 
  theme_bw(base_size = 9) + 
  #coord_cartesian(ylim=c(0,300))+ 
  coord_cartesian(xlim=c(-12,7)) +
  scale_color_manual(values=c("red","black")) +
  ggtitle("PV vs MG differentially expressed genes") +
  geom_text_repel(data=filter(PV_DEGs, abs(logFC)>3.2),
                  #family = "Times New Roman", 
                  aes(label=gene_id),
                  #size = 2, 
                  arrow = arrow(length = unit(0.01, 'npc')), 
                  force = 7,box.padding = unit(0.4, "lines"), 
                  point.padding = unit(0.3, "lines"))
ggsave("../figures/PV-MG_DEG_volcanoplot.png", device = "png")

#####################################
# create a venn diagram to show distribution of the number DEGs between stages
PV_data_tmp <- PV_data %>% tibble::column_to_rownames("gene_id")
SG_data_tmp <- SG_data %>% tibble::column_to_rownames("gene_id")

png(filename = "../figures/venn_de_genes.png", res =1200, type = "cairo", units = 'in',
    width = 5, height = 4, pointsize = 10)
vd <- venn.diagram(x = list("MG vs PV" = rownames(PV_data_tmp),
                            "SG vs PV" = rownames(SG_data_tmp)),
                   fill = brewer.pal(3, "Set2")[1:2], filename = NULL)
grid.draw(vd)
dev.off()

# clean up
rm(PV_data_tmp, SG_data_tmp)
```

```{r, fig.cap="Venn diagram showing differentially expressed genes", echo=FALSE, out.width='75%', eval=FALSE}
# venn diagram
include_graphics("../figures/venn_de_genes.png")
```
\newpage
```{r, fig.cap="Differentially expressed genes in the proventriculus compared to midgut", echo=FALSE, out.width='75%', eval=FALSE}
# Genes differentially expressed in proventriculus compared to midgut (above p<0.05)
include_graphics("../figures/PV-MG_DEG_volcanoplot.png")
```

```{r, fig.cap="Differentially expressed genes in the salivary gland compared to proventriculus", echo=FALSE, out.width='75%', eval=FALSE}
# Genes differentially expressed in salivary gland compared to proventriculus (above p<0.05)
include_graphics("../figures/SG-PV_DEG_volcanoplot.png")
```


### Weighted gene co-expression analysis

```{r, code = readLines(here::here("scripts","13_coexpression-network-construction.R")), eval=FALSE}

```

```{r echo=FALSE, out.width='80%', eval=FALSE}

include_graphics("../figures/soft-thresholding_power.png")
```

```{r echo=FALSE, out.width='80%', eval=FALSE}

include_graphics("../figures/mean_connectivity.png")
```


```{r fig.cap="Adjacency matrix heatmap (500 genes)", echo=FALSE, eval=FALSE, out.width='80%'}

include_graphics("../figures/adjacency_matrix_heatmap.png")
```



```{r fig.cap="Gene tree and module colours", echo=FALSE, out.width='80%', eval=FALSE}

include_graphics("../figures/gene_tree_and_colours.png")
```


```{r, eval=FALSE, echo=FALSE}
#The section below is included for further checks so it may not be necessary to carry out this analysis.

# --------------------------------------------------------------------------------------------
# merge modules with very similar expression profiles as their genes are highly co-expressed
# get the module eigengenes
module.eigengenes <- moduleEigengenes(network.counts, colors = module.colours)$eigengenes

# calculate dissimilarity of module eigengenes using correlations
module.eigengenes.diss <- 1 - cor(module.eigengenes)

# cluster module eigengenes
module.eigengenes.tree <- flashClust(as.dist(module.eigengenes.diss), method = "average")

# choose height at which to cut the tree for merge i.e. the threshold
module.eigengenes.thresh <- 0.25

# create plots for the results
png(filename = "../figures/module_eigengenes_cluster.png", res =1200, type = "cairo", units = 'in',
    width = 5, height = 6, pointsize = 10)
#sizeGrWindow(7, 6)
plot(module.eigengenes.tree, main = "Clustering of module eigengenes", xlab = "", sub = "")
abline(h=module.eigengenes.thresh, col="red")

dev.off()

# merge the modules
module.eigengenes.merge <- mergeCloseModules(network.counts, module.colours, 
                                             cutHeight = module.eigengenes.thresh)

# merged module colours
merged.module.colours <- module.eigengenes.merge$colors

# view
table(merged.module.colours)

# a list of 13 modules

      black        blue       brown    darkgrey     darkred       green 
        438        1565         735         477         796         728 
greenyellow        grey  lightgreen         red      salmon       white 
        515          59         164         703         230         441 
     yellow 
        539

# eigengenes of new merged modules
merged.module.eigengenes <- module.eigengenes.merge$newMEs

```

```{r, eval=FALSE, echo=FALSE}

# plot the dendrogram with original and merged colours underneath
#sizeGrWindow(12, 9)
png(filename = "../figures/merged-original_colours-original_dendro.png", res =1200, type = "cairo", 
    units = 'in', width = 6, height = 6, pointsize = 10)
plotDendroAndColors(gene.tree, cbind(module.colours, merged.module.colours), 
                    c("Dynamic Tree Cut", "Merged dynamic"), 
                    dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05)
dev.off()

# plot heatmap of eigengenes (orginal before merge)
png(filename = "../figures/eigengenes_heatmap.png", res =1200, type = "cairo", units = 'in',
    width = 5, height = 6, pointsize = 10)
plotEigengeneNetworks(module.eigengenes, "Eigengenes heatmap", marHeatmap = c(3,4,2,2),
                      plotDendrograms = FALSE, xLabelsAngle = 90)
dev.off()
```


```{r fig.cap="Dendrogram with original and merged colours", echo=FALSE, out.width='80%', eval=FALSE}

include_graphics("../figures/merged-original_colours-original_dendro.png")
```

```{r, eval=FALSE, echo=FALSE}

#-----------------------------------------------------------------------------------------
# rename some variables based on the module eigengene analysis for later use
#
# module colours
#module.colours <- merged.module.colours

# construct numerical labels corresponding to the colours
colorOrder <- c("grey", standardColors(50))
#module.labels <- match(module.colours, colorOrder)-1

# module eigengenes
#module.eigengenes <- merged.module.eigengenes

# get hub genes
merged.module.hub.genes <- chooseTopHubInEachModule(network.counts,
                                                    merged.module.colours,
                                                    power = 4,
                                                    type = "signed")

# a list of merged module hub genes
           black             blue            brown         darkgrey 
  "Tb927.7.1790"   "Tb927.1.3130" "Tb927.11.14220"   "Tb927.11.760" 
         darkred            green      greenyellow       lightgreen 
  "Tb927.5.1050"   "Tb927.8.6580" "Tb927.11.10610"   "Tb927.10.720" 
             red           salmon            white           yellow 
"Tb927.10.14900"  "Tb927.11.1450"   "Tb927.8.3530"   "Tb927.1.3550"

```



```{r fig.cap="Co-expression subnetwork", echo=FALSE,out.width='99%', eval=FALSE}

include_graphics("../results/tbrucei_network.png")
```

## Functional Analysis

Code used in finctional analysis was adopted from https://github.com/elsayed-lab/manuscript-shared-rnaseq

### Loading annotations from the packages

```{r, code = readLines(here::here("scripts","14_functional-analysis.R")), eval=FALSE}

```


```{r fig.cap="Gene tree and module enrichment status", eval=FALSE, echo=FALSE, out.width='80%'}

include_graphics("../figures/gene_tree_and_module_enrichment_status.png")
```


## FIRE (Finding Informative Regulatory Elements)
Module genes and their module labels are required as input by FIRE (Finding Informative Regulatory Elements). Hence we write out text files with this input. Motif prediction was performed online at https://tavazoielab.c2b2.columbia.edu/FIRE/

```{r, code = readLines(here::here("scripts","15_FIRE-input.R")), eval=FALSE}

```

```{bash, eval=FALSE, engine="sh", echo=FALSE}

#Prepare input sequences for FIRE by obtaining module genes sequences from *T. brucei*'s entire annotated transcripts. Use `seqtk` package.


# remove unrequired info from header and retain gene id.
cut -f2 -d "|" ../data/tbrucei_annotated_transcripts/TriTrypDB-43_TbruceiTREU927_AnnotatedTranscripts.fasta | cut -f2 -d " " | cut -f1 -d " " | cut -f2 -d "=" > ../results/tbrucei_annotated_transcript_sequences_gene_as_header.fasta

# add ">" symbol to header
awk '{ if ($0 ~ /Tb/) { printf ">"; } print $0; }' ../results/tbrucei_annotated_transcript_sequences_gene_as_header.fasta > ../results/tbrucei_annotated_transcript_sequences.fasta

# obtain module gene sequences
seqtk subseq ../results/tbrucei_annotated_transcript_sequences.fasta \
../results/tbrucei_module_genes.txt > \
../results/tbrucei_module_genes_sequences_FIRE_input.fasta

seqkit grep -n -f ../results/tbrucei_module_genes_sorted.txt ../results/tbrucei_annotated_transcript_sequences.fasta > ../results/tbrucei_module_genes_sequences_FIRE_input.fasta1

# FIRE commands - FIRE should be run in the directory where all scripts were installed. Therefore,
# the input files should be copied to FIRE's directory (FIRE-x.x/)
#
#check whether input files are OK
perl TOOLS/FIRE_analyse_input_files.pl \
-fastafile tbrucei_module_genes_sequences_without_delimiter.fasta \
-expfile tbrucei_FIRE_expression_clusters.txt

# remove sequences >= 10,000 base pairs as they make FIRE crash
# code - https://www.biostars.org/p/62678/
 cat ../results/tbrucei_module_genes_sequences_without_delimiter.fasta | \
 awk '{y= i++ % 2 ; L[y]=$0; if(y==1 && length(L[1])<=9999) {printf("%s\n%s\n",L[0],L[1]);}}' > \
../results/tbrucei_module_genes_sequences_without_delimiter_filtered.fasta

# recheck input files
perl TOOLS/FIRE_analyse_input_files.pl \
-fastafile tbrucei_module_genes_sequences_without_delimiter_filtered.fasta \
-expfile tbrucei_FIRE_expression_clusters.txt

# output
#Checking the expression file
#Expression file is OK.
#
#Checking the fasta file
#Fasta file is OK (min sequence length = 98, max length = 9917).
#
#Found fasta sequence for 7272 / 7390 identifiers in expression file.

# Analyze sequences for motifs
 perl fire.pl --expfiles=tbrucei_FIRE_expression_clusters.txt --exptype=discrete \
 --fastafile_dna=tbrucei_module_genes_sequences_without_delimiter_filtered.fasta  --nodups=1

# create HTML output of the results
perl MORESCRIPTS/makeresultindex.pl tbrucei_FIRE_expression_clusters.txt "T. brucei cluster motifs"
```

